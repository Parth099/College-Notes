Lectures 1/24/22 & 1/26/22 

# Week 2 -  C?
## Why C?
Often times C is the only language available:
- Low Level embedded systems
	- Many Low Level situations do *not* support "high-level" languages 
	- Many Higher level languages do not have direct control over OS, Hardware & Drivers.
C is usually used to develop systems that demanded performance such as OS, embedded systems, real-time(Systems that must work continuously with minimal delay) & Communications systems(requires data throughput like audio/video).

C requires less maintenance and is closer to the hardware.

## Facts about C
1960s: MIT MULTICS project fails to live up to expectations
- Thompson creates own System language based on BCPL called *B*. First version of Unix written in *B*
- Unix takes hold inside Bell labs
	- needs to be written 
It is called "**C**" because it is derived from an earlier language B #ðŸ˜„ 

OOP begins to emerge:
- Stroustrup starts C with *Classes* in 1997(C++)
- Backwards Compatible with C

## Why not C?
Unlike Java, C is Write Once run once. It depends on the memory available & memory.
Data Structures must be programmed "by hand".
No Support for OOP
Much harder to use than higher level language. $\implies$ longer time to code in C than a higher level language.


### C++ Info
#### Pros
- OOP, Classes & Inheritance
#### Cons
Issues from C persist
- Complex Memory Model with self memory management
#### Java
Jim Gosling at Sun Micro-systems rewrites C++ to Java
- Simpler Obj Model
- Portable, embedded in many systems
	- Portable: Write Once run anywhere as long as it has a JVM

## Languages Based on C
#TestQ
- C-Family: Objective C(Apple's Language), C#(MSFT)
- Swift(Apple's new language)
- Java
- PHP, Python, JavaScript

## C Program Development Environment/Lifecycle
#TestQ 
### Steps Overview 
1. Edit
2. Preprocess
3. Compile
4. Link
5. Load
6. Execute

## CLASS EXT
See Firmware