# Pointers
A pointer provides indirect control over a variable. 
Pointers allow us to work with *raw* memory locations. This was useful when systems had less total memory space but isn't the most useful now. 

They allow a program to utilize less memory and run faster. 

## Usage
Pointers are used in 3 **key** ways
1. simulate pass-by-reference 
2. pass functions between functions
3. creating dynamic data structures

This is why we use pointers above arrays. Creation Arrays require future knowledge about size. With pointers they can be allocated memory from the heap over runtime.

## Code
```c
int main(void)
{
	int a = 7;
	int *aPtr = &a; //pointer to a 
	printf("Address: %p\nValue: %d", aPtr, a);
	//aPtr is the same as &a
	
	//Pointers also have a pointer. 
	printf("Pointer Addess: %p", &aPtr);
}
```
```out
[OUTPUT]
Address: 0000007b433ff7dc
Value: 7
Pointer Addess: 0000007b433ff7d0
```
See that `int *aPtr` is a datatype that describes a pointer to an integer. 
1. `&` reference operator
2. `*` de-reference operator

They both run right to left.
```c
int p = &b;
```

## Pointer Reqs.
+ Never allow pointers to be un-initialized
	+ They can be initialized to `NULL`, 0, or an address
	+ A pointer to `NULL` points to *nothing*
	+ `NULL` is a symbolic constant defined in the `stddef.h` and several other header files.
	+ Assigning to 0 is the same as `NULL` but `NULL` is preferred for readability
## Pointers and Strings
A `char *` is really a String. 
```c
char c = 'A';
char *cptr;
cptr = &c;
```
## Pointer Example
![[mem-infogph.png]]
```c
int main(){
	//make it point to null for system safty
	int *ptr = NULL; //declare ptr to int type 
	int a, b;
	
	a = 12;
	ptr = &a; //set pointer value to a's address
	//use * to pull the value out of 0x0A: a's address
	b = *(ptr);
}
```
A pointer with no value is called "dangling pointer". 
## Pointer Size
A pointer to `float` is the same size as an `int`. A pointer just holds an memory address and thus should be the same WRT the machine.
+ 32 bit machine - 4 bytes
+ 64 bit machine - 8 bytes

## Pointer Functional implementations
```c
void cubeByReference(int *nPtr); //proto

int main()
{
	int n = 5;
	printf("%d", cubeByReference(&n));
}
//modifies the actual number n from main.
void cubeByReference(int *nPtr)
{
	*nPtr = *nPtr * *nPtr * *nPtr
}
```

## `Null` vs `void *`
A `void*` has a pointer without a type.

## Using the `const` Qualifier with Pointers
### 4 ways to pass points
1. `non-constant` pointer to `non-constant` data
2. `const` pointer to `non-constant` data. 
	-	We can only use the pointer we cannot move the pointer to another location
3. `non-constant` pointer to `const` data
4. `const` pointer to `const` data

Each of the four combos provides different access privs.
### Examples
#### A
```c
//void convertToUpperCase(char *sPtr);
void convertToUpperCase(char *sPtr)
{
	while(*sPtr != '\0'){
		*sPtr = toupper(*sPtr); //works on single chars
		++sPtr; 
	//moves pointer to next memory cell via pointer arith
	}
}
```
This function will convert all *valid* chars to uppercase.
`toupper(char* c)` is from `<ctype.h>`:
> header file of the C Standard Library declares several functions that are useful for testing and mapping characters
```c
int main(void)
{
	char string[] = "cHaRaCters and $32.98";
	printf("\nBefore :%s", string); 
	//"cHaRaCters and $32.98"
	convertToUpperCase(string);
	printf("\nAfter :%s", string);
	//"CHARACTERS AND $32.98"
}

```
The data is ***permanently*** changed now.
#### B.1
```c
//notice how the char pointer is now constant
void printCharacters(const char *sPtr)
{
	for(; *sPtr != '\0'; sPtr++){
		printf("%c", *sPtr);
	}	
}

int main(void)
{
	char string[] = "print characters of a string";
	
	puts("The string was:");
	printCharacters(string);
}
```

The pointer `const char *sPtr` means `sPtr` is **read-only**. It cannot modify the character it points at. 

#### b.2
```c
void f(const int *xPtr)
{
	*xPtr = 5; //error: attemp to modify const dt
}

int main(void)
{
	int y = 4;
	f(&y); //error
	//f attemps ILLEGAL modification
}
```
#### c
```c
int main(void){
	
	//define
	int x, y;
	
	/*
	ptr is a constant pointer to an int but it can 
	now be changed. But we cannot move the pointer
	to a new memory address.
	*/
	int * const ptr = &x;
	
	*ptr = 17; //valid, *ptr is NOT constant
	ptr = &y; 
	//error ptr IS constant 
	// => cannot assign new address
}
```

Read pointer declaration from right to left. This way we note that the **pointer is constant** and not the data. In Examples **B.1-2**, the data was constant and not the actual pointer. 

In short, we need to check what is actually constant, the pointer or the data type. 
%%end of lecture 2/21/22%%
## 
